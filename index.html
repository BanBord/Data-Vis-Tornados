<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visualization Tornados</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="lib/gmynd.js"></script> <!-- Include gmynd library -->

    <style>
        /* Your custom CSS code here */
        body { margin: 0; }
        svg { width: 100%; height: 100vh; }
        .county-label {
            font-size: 10px;
            fill: #000;
            text-anchor: middle;
        }
    </style>
</head>
<body>
    <h1>Data Visualization Tornados</h1>
    <div id="map-container"></div>
    <script>
        // Set up SVG container
        const width = window.innerWidth;
        const height = window.innerHeight;
        const svg = d3.select("#map-container").append("svg")
            .attr("width", width)
            .attr("height", height);

        // Define a projection and path generator
        const projection = d3.geoAlbersUsa().scale(1300).translate([width / 2, height / 2]);
        const path = d3.geoPath().projection(projection);

        // Load and process TopoJSON and Tornado data
        Promise.all([
            d3.json('topojson.json'),
            d3.json('tornados_short.json')
        ]).then(([topoData, tornadoData]) => {
            const counties = topojson.feature(topoData, topoData.objects.counties).features;

            // Filter tornado data for a specific year, e.g., 1950
            const year = 2011;
            const filteredTornadoData = tornadoData.tornadoData.filter(d => d.yr === year);

            // Group tornado data by FIPS for the specific year
            const groupedByFIPSCode = gmynd.groupData(filteredTornadoData, ['FIPS']);

            // Flatten the grouped data
            const flattenedData = Object.keys(groupedByFIPSCode).map(key => {
                return groupedByFIPSCode[key].map(item => ({ ...item, FIPS: key }));
            }).flat();

            // Cumulate tornado data by FIPS for the specific year
            const cumulatedData = gmynd.cumulateData(flattenedData, ['FIPS'], [{ value: 'FIPS', method: 'count', title: 'tornadoCount' }]);
            console.log(cumulatedData);

            // Combine cumulated data with TopoJSON data
            counties.forEach(county => {
                const fips = county.id;
                const tornadoData = cumulatedData.find(d => d.FIPS == fips);
                county.properties.tornadoCount = tornadoData ? tornadoData.tornadoCount : 0;
            });

            // Extract tornado counts for color mapping
            const tornadoCounts = cumulatedData.map(d => d.tornadoCount);
            const maxTornadoCount = d3.max(tornadoCounts);
            console.log(maxTornadoCount);

            // Define a color mapping function using gmynd.map
            const colorMapping = d => {
                const normalizedValue = gmynd.map(d.properties.tornadoCount, 0, maxTornadoCount, 0, 1);
                return d3.interpolateReds(normalizedValue);
            };

            // Draw counties with a stroke and fill color based on tornado count
            svg.selectAll("path")
                .data(counties)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", colorMapping) // Fill color based on tornado count using gmynd.map
                .attr("stroke", "#000000") // Black stroke for county borders
                .attr("stroke-width", 0.5) // Stroke width
                .attr("name", d => d.properties.name)
                .attr("ID", d => d.id);

        }).catch(error => {
            console.error('Error loading the data:', error);
        });
    </script>
</body>
</html>